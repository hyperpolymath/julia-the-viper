// Julia the Viper - Pest Grammar for Rust Parser
// Harvard Architecture: Control (Turing-complete) + Data (Total)

WHITESPACE = _{ " " | "\t" | "\r" | "\n" }
COMMENT = _{ line_comment | block_comment }
line_comment = { "//" ~ (!"\n" ~ ANY)* }
block_comment = { "/*" ~ (!"*/" ~ ANY)* ~ "*/" }

// ===== PROGRAM STRUCTURE =====
program = { SOI ~ (module_decl | import_stmt | function_decl | control_stmt)* ~ EOI }

module_decl = { "module" ~ identifier ~ "{" ~ (function_decl | control_stmt)* ~ "}" }

import_stmt = { "import" ~ module_path ~ ("as" ~ identifier)? }
module_path = { identifier ~ ("." ~ identifier)* }

// ===== CONTROL LANGUAGE =====
control_stmt = {
    assignment
    | if_stmt
    | while_stmt
    | for_stmt
    | return_stmt
    | print_stmt
    | reverse_block
    | block
}

assignment = { identifier ~ "=" ~ (data_expr | control_expr) }

if_stmt = { "if" ~ control_expr ~ block ~ ("else" ~ block)? }

while_stmt = { "while" ~ control_expr ~ block }

for_stmt = { "for" ~ identifier ~ "in" ~ range_expr ~ block }

return_stmt = { "return" ~ data_expr? }

print_stmt = { "print" ~ "(" ~ data_expr ~ ("," ~ data_expr)* ~ ")" }

block = { "{" ~ control_stmt* ~ "}" }

reverse_block = { "reverse" ~ "{" ~ reversible_stmt* ~ "}" }
reversible_stmt = { reversible_assignment | if_stmt }
reversible_assignment = { identifier ~ reversible_op ~ data_expr }
reversible_op = { "+=" | "-=" }

// ===== DATA LANGUAGE (Total, addition-only) =====
data_expr = { additive_expr }

additive_expr = { term ~ ("+" ~ term)* }

term = { factor }

factor = {
    number
    | function_call
    | identifier
    | list_literal
    | tuple_literal
    | unary_op ~ factor
    | "(" ~ data_expr ~ ")"
}

unary_op = { "-" | "!" }

// ===== CONTROL EXPRESSIONS =====
control_expr = {
    logical_expr
    | comparison_expr
    | data_expr
}

comparison_expr = { data_expr ~ comparator ~ data_expr }
comparator = { "==" | "!=" | "<=" | ">=" | "<" | ">" }

logical_expr = { logical_term ~ ("||" ~ logical_term)* }
logical_term = { logical_factor ~ ("&&" ~ logical_factor)* }
logical_factor = { "!" ~ logical_factor | comparison_expr | data_expr | "(" ~ control_expr ~ ")" }

// ===== FUNCTIONS =====
function_decl = {
    purity_marker? ~ "fn" ~ identifier ~ "(" ~ param_list? ~ ")" ~ (":" ~ return_type)? ~ block
}

purity_marker = { "@pure" | "@total" }

param_list = { param ~ ("," ~ param)* }
param = { identifier ~ (":" ~ type_annotation)? }

// Function calls support qualified names: Module.submod.func(args)
function_call = { qualified_name ~ "(" ~ arg_list? ~ ")" }
qualified_name = { identifier ~ ("." ~ identifier)* }
arg_list = { data_expr ~ ("," ~ data_expr)* }

// ===== TYPE SYSTEM =====
type_annotation = {
    function_type
    | list_type
    | tuple_type
    | basic_type
}

basic_type = {
    "Int" | "Float" | "Rational" | "Complex"
    | "Hex" | "Binary" | "Symbolic" | "Bool" | "String"
}

list_type = { "List" ~ "<" ~ type_annotation ~ ">" }
tuple_type = { "(" ~ type_annotation ~ ("," ~ type_annotation)+ ~ ")" }
function_type = { "Fn" ~ "(" ~ (type_annotation ~ ("," ~ type_annotation)*)? ~ ")" ~ "->" ~ type_annotation }

return_type = { type_annotation }

// ===== LITERALS =====
number = {
    complex
    | rational
    | hex
    | binary
    | float
    | integer
}

integer = @{ "-"? ~ ASCII_DIGIT+ }
float = @{ "-"? ~ ASCII_DIGIT+ ~ "." ~ ASCII_DIGIT+ ~ (("e" | "E") ~ ("+" | "-")? ~ ASCII_DIGIT+)? }
rational = @{ integer ~ "/" ~ ASCII_NONZERO_DIGIT ~ ASCII_DIGIT* }
complex = @{ (float | integer) ~ "+" ~ (float | integer) ~ "i" | (float | integer) ~ "i" }
hex = @{ "0x" ~ ASCII_HEX_DIGIT+ }
binary = @{ "0b" ~ ("0" | "1")+ }

list_literal = { "[" ~ (data_expr ~ ("," ~ data_expr)*)? ~ "]" }
tuple_literal = { "(" ~ data_expr ~ "," ~ data_expr ~ ("," ~ data_expr)* ~ ")" }

range_expr = { data_expr ~ ".." ~ data_expr ~ (".." ~ data_expr)? }

string = ${ "\"" ~ string_inner ~ "\"" }
string_inner = @{ (!"\"" ~ !"\\" ~ ANY | escape_sequence)* }
escape_sequence = @{ "\\" ~ ("n" | "t" | "r" | "\"" | "\\") }

// ===== IDENTIFIERS =====
identifier = @{ !keyword ~ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")* }

keyword = {
    "module" | "import" | "as" | "fn" | "return" | "if" | "else" | "while" | "for" | "in"
    | "print" | "reverse" | "Int" | "Float" | "Rational" | "Complex" | "Hex" | "Binary"
    | "Symbolic" | "Bool" | "String" | "List" | "Fn" | "true" | "false"
}
