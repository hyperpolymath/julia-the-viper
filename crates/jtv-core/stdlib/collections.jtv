// JtV Standard Library - Collections
// Data structure operations and algorithms

module Collections {
    // ===== LIST OPERATIONS =====

    @pure fn map(list: List<Int>, fn_name: String): List<Int> {
        // In real implementation, would support higher-order functions
        // Simplified version
        result = []
        for item in list {
            // Apply function to item
            result = result + [item]
        }
        return result
    }

    @pure fn filter_positive(list: List<Int>): List<Int> {
        result = []
        for item in list {
            if item > 0 {
                result = result + [item]
            }
        }
        return result
    }

    @pure fn filter_even(list: List<Int>): List<Int> {
        result = []
        for item in list {
            if mod(item, 2) == 0 {
                result = result + [item]
            }
        }
        return result
    }

    @pure fn take(list: List<Int>, n: Int): List<Int> {
        result = []
        count = 0
        for item in list {
            if count < n {
                result = result + [item]
                count = count + 1
            }
        }
        return result
    }

    @pure fn drop(list: List<Int>, n: Int): List<Int> {
        result = []
        count = 0
        for item in list {
            if count >= n {
                result = result + [item]
            }
            count = count + 1
        }
        return result
    }

    @pure fn reverse(list: List<Int>): List<Int> {
        result = []
        len = length(list)

        for i in 0..len {
            idx = len - 1 - i
            result = result + [list[idx]]
        }

        return result
    }

    @pure fn concat(list1: List<Int>, list2: List<Int>): List<Int> {
        result = list1
        for item in list2 {
            result = result + [item]
        }
        return result
    }

    @pure fn contains(list: List<Int>, value: Int): Int {
        for item in list {
            if item == value {
                return 1
            }
        }
        return 0
    }

    @pure fn index_of(list: List<Int>, value: Int): Int {
        idx = 0
        for item in list {
            if item == value {
                return idx
            }
            idx = idx + 1
        }
        return -1  // Not found
    }

    @pure fn count(list: List<Int>, value: Int): Int {
        count = 0
        for item in list {
            if item == value {
                count = count + 1
            }
        }
        return count
    }

    // ===== SORTING =====

    fn bubble_sort(list: List<Int>): List<Int> {
        len = length(list)

        for i in 0..len {
            for j in 0..len-i-1 {
                if list[j] > list[j+1] {
                    temp = list[j]
                    list[j] = list[j+1]
                    list[j+1] = temp
                }
            }
        }

        return list
    }

    fn insertion_sort(list: List<Int>): List<Int> {
        len = length(list)

        for i in 1..len {
            key = list[i]
            j = i - 1

            while j >= 0 && list[j] > key {
                list[j+1] = list[j]
                j = j - 1
            }

            list[j+1] = key
        }

        return list
    }

    @pure fn is_sorted(list: List<Int>): Int {
        len = length(list)

        for i in 0..len-1 {
            if list[i] > list[i+1] {
                return 0
            }
        }

        return 1
    }

    // ===== SEARCHING =====

    @pure fn find_min(list: List<Int>): Int {
        if length(list) == 0 {
            return 0
        }

        min_val = list[0]
        for item in list {
            if item < min_val {
                min_val = item
            }
        }

        return min_val
    }

    @pure fn find_max(list: List<Int>): Int {
        if length(list) == 0 {
            return 0
        }

        max_val = list[0]
        for item in list {
            if item > max_val {
                max_val = item
            }
        }

        return max_val
    }

    fn binary_search(sorted_list: List<Int>, target: Int): Int {
        left = 0
        right = length(sorted_list) - 1

        while left <= right {
            mid = divide(left + right, 2)

            if sorted_list[mid] == target {
                return mid
            } else if sorted_list[mid] < target {
                left = mid + 1
            } else {
                right = mid - 1
            }
        }

        return -1  // Not found
    }

    // ===== STATISTICAL FUNCTIONS =====

    @pure fn sum(list: List<Int>): Int {
        total = 0
        for item in list {
            total = total + item
        }
        return total
    }

    @pure fn mean(list: List<Int>): Int {
        total = sum(list)
        len = length(list)
        return divide(total, len)
    }

    @pure fn median(sorted_list: List<Int>): Int {
        len = length(sorted_list)
        mid = divide(len, 2)

        if mod(len, 2) == 0 {
            // Even: average of two middle elements
            return divide(sorted_list[mid-1] + sorted_list[mid], 2)
        } else {
            // Odd: middle element
            return sorted_list[mid]
        }
    }

    @pure fn mode(list: List<Int>): Int {
        // Find most frequent element
        max_count = 0
        mode_val = 0

        for item in list {
            item_count = count(list, item)
            if item_count > max_count {
                max_count = item_count
                mode_val = item
            }
        }

        return mode_val
    }

    // ===== SET OPERATIONS =====

    @pure fn unique(list: List<Int>): List<Int> {
        result = []

        for item in list {
            if contains(result, item) == 0 {
                result = result + [item]
            }
        }

        return result
    }

    @pure fn union(list1: List<Int>, list2: List<Int>): List<Int> {
        combined = concat(list1, list2)
        return unique(combined)
    }

    @pure fn intersection(list1: List<Int>, list2: List<Int>): List<Int> {
        result = []

        for item in list1 {
            if contains(list2, item) == 1 && contains(result, item) == 0 {
                result = result + [item]
            }
        }

        return result
    }

    @pure fn difference(list1: List<Int>, list2: List<Int>): List<Int> {
        result = []

        for item in list1 {
            if contains(list2, item) == 0 {
                result = result + [item]
            }
        }

        return result
    }

    // ===== UTILITY FUNCTIONS =====

    fn multiply(a: Int, b: Int): Int {
        result = 0
        for i in 0..abs(b) {
            result = result + abs(a)
        }
        if (a < 0 && b > 0) || (a > 0 && b < 0) {
            return -result
        }
        return result
    }

    fn divide(a: Int, b: Int): Int {
        if b == 0 {
            return 0
        }

        quotient = 0
        remainder = abs(a)
        divisor = abs(b)

        while remainder >= divisor {
            remainder = remainder - divisor
            quotient = quotient + 1
        }

        if (a < 0 && b > 0) || (a > 0 && b < 0) {
            return -quotient
        }
        return quotient
    }

    fn mod(a: Int, b: Int): Int {
        quotient = divide(a, b)
        product = multiply(quotient, b)
        return a - product
    }

    @pure fn abs(x: Int): Int {
        if x < 0 {
            return -x
        } else {
            return x
        }
    }

    @pure fn length(list: List<Int>): Int {
        count = 0
        for item in list {
            count = count + 1
        }
        return count
    }
}
